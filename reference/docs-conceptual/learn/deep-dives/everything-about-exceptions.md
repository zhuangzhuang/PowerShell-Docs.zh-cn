---
title: 关于异常的各项须知内容
description: 错误处理只是编写代码时的一部分工作。
ms.date: 05/23/2020
ms.custom: contributor-KevinMarquette
ms.openlocfilehash: 589e5d1decff7aa49ce36e10908e4464a768758d
ms.sourcegitcommit: 1dfd5554b70c7e8f4e3df19e29c384a9c0a4b227
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/03/2021
ms.locfileid: "101685510"
---
# <a name="everything-you-wanted-to-know-about-exceptions"></a><span data-ttu-id="cb66a-103">关于异常的各项须知内容</span><span class="sxs-lookup"><span data-stu-id="cb66a-103">Everything you wanted to know about exceptions</span></span>

<span data-ttu-id="cb66a-104">错误处理只是编写代码时的一部分工作。</span><span class="sxs-lookup"><span data-stu-id="cb66a-104">Error handling is just part of life when it comes to writing code.</span></span> <span data-ttu-id="cb66a-105">我们通常可以检查并验证预期行为的条件。</span><span class="sxs-lookup"><span data-stu-id="cb66a-105">We can often check and validate conditions for expected behavior.</span></span> <span data-ttu-id="cb66a-106">发生意外情况时，我们会转向异常处理。</span><span class="sxs-lookup"><span data-stu-id="cb66a-106">When the unexpected happens, we turn to exception handling.</span></span> <span data-ttu-id="cb66a-107">你可以轻松处理他人的代码生成的异常，也可以自己生成一些异常让他人去处理。</span><span class="sxs-lookup"><span data-stu-id="cb66a-107">You can easily handle exceptions generated by other people's code or you can generate your own exceptions for others to handle.</span></span>

> [!NOTE]
> <span data-ttu-id="cb66a-108">本文的[原始版本][]发布在 [@KevinMarquette][] 撰写的博客上。</span><span class="sxs-lookup"><span data-stu-id="cb66a-108">The [original version][] of this article appeared on the blog written by [@KevinMarquette][].</span></span> <span data-ttu-id="cb66a-109">PowerShell 团队感谢 Kevin 与我们分享这篇文章。</span><span class="sxs-lookup"><span data-stu-id="cb66a-109">The PowerShell team thanks Kevin for sharing this content with us.</span></span> <span data-ttu-id="cb66a-110">请前往 [PowerShellExplained.com][] 访问他的博客。</span><span class="sxs-lookup"><span data-stu-id="cb66a-110">Please check out his blog at [PowerShellExplained.com][].</span></span>

## <a name="basic-terminology"></a><span data-ttu-id="cb66a-111">基本术语</span><span class="sxs-lookup"><span data-stu-id="cb66a-111">Basic terminology</span></span>

<span data-ttu-id="cb66a-112">在进入正题之前，我们需要介绍一些基本术语。</span><span class="sxs-lookup"><span data-stu-id="cb66a-112">We need to cover some basic terms before we jump into this one.</span></span>

### <a name="exception"></a><span data-ttu-id="cb66a-113">异常</span><span class="sxs-lookup"><span data-stu-id="cb66a-113">Exception</span></span>

<span data-ttu-id="cb66a-114">异常就是常规错误处理程序无法处理问题时创建的事件。</span><span class="sxs-lookup"><span data-stu-id="cb66a-114">An Exception is like an event that is created when normal error handling can't deal with the issue.</span></span>
<span data-ttu-id="cb66a-115">尝试将数字除以零或内存不足等都会造成异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-115">Trying to divide a number by zero or running out of memory are examples of something that creates an exception.</span></span> <span data-ttu-id="cb66a-116">有时，你使用的代码的作者会在某些问题发生时为它们创建异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-116">Sometimes the author of the code you're using creates exceptions for certain issues when they happen.</span></span>

### <a name="throw-and-catch"></a><span data-ttu-id="cb66a-117">Throw 和 Catch</span><span class="sxs-lookup"><span data-stu-id="cb66a-117">Throw and Catch</span></span>

<span data-ttu-id="cb66a-118">发生异常时，我们会说一个异常被引发。</span><span class="sxs-lookup"><span data-stu-id="cb66a-118">When an exception happens, we say that an exception is thrown.</span></span> <span data-ttu-id="cb66a-119">若要处理引发的异常，需要将其捕获。</span><span class="sxs-lookup"><span data-stu-id="cb66a-119">To handle a thrown exception, you need to catch it.</span></span> <span data-ttu-id="cb66a-120">如果异常被引发但未被捕获，则脚本将停止执行。</span><span class="sxs-lookup"><span data-stu-id="cb66a-120">If an exception is thrown and it isn't caught by something, the script stops executing.</span></span>

### <a name="the-call-stack"></a><span data-ttu-id="cb66a-121">调用堆栈</span><span class="sxs-lookup"><span data-stu-id="cb66a-121">The call stack</span></span>

<span data-ttu-id="cb66a-122">调用堆栈是相互调用的函数的列表。</span><span class="sxs-lookup"><span data-stu-id="cb66a-122">The call stack is the list of functions that have called each other.</span></span> <span data-ttu-id="cb66a-123">当调用一个函数时，它将被添加到堆栈或列表的顶部。</span><span class="sxs-lookup"><span data-stu-id="cb66a-123">When a function is called, it gets added to the stack or the top of the list.</span></span> <span data-ttu-id="cb66a-124">当函数退出或返回时，它将从堆栈中移除。</span><span class="sxs-lookup"><span data-stu-id="cb66a-124">When the function exits or returns, it is removed from the stack.</span></span>

<span data-ttu-id="cb66a-125">当引发异常时，将检查该调用堆栈，以便异常处理程序捕获异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-125">When an exception is thrown, that call stack is checked in order for an exception handler to catch it.</span></span>

### <a name="terminating-and-non-terminating-errors"></a><span data-ttu-id="cb66a-126">终止和非终止错误</span><span class="sxs-lookup"><span data-stu-id="cb66a-126">Terminating and non-terminating errors</span></span>

<span data-ttu-id="cb66a-127">异常通常是终止错误。</span><span class="sxs-lookup"><span data-stu-id="cb66a-127">An exception is generally a terminating error.</span></span> <span data-ttu-id="cb66a-128">引发的异常要么被捕获要么会终止当前执行程序。</span><span class="sxs-lookup"><span data-stu-id="cb66a-128">A thrown exception is either be caught or it terminates the current execution.</span></span> <span data-ttu-id="cb66a-129">默认情况下，`Write-Error` 会生成一个非终止错误，并将错误添加到输出流，而不引发异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-129">By default, a non-terminating error is generated by `Write-Error` and it adds an error to the output stream without throwing an exception.</span></span>

<span data-ttu-id="cb66a-130">我指出这一点，是因为 `Write-Error` 和其他非终止错误不会触发 `catch`。</span><span class="sxs-lookup"><span data-stu-id="cb66a-130">I point this out because `Write-Error` and other non-terminating errors do not trigger the `catch`.</span></span>

### <a name="swallowing-an-exception"></a><span data-ttu-id="cb66a-131">忽略异常</span><span class="sxs-lookup"><span data-stu-id="cb66a-131">Swallowing an exception</span></span>

<span data-ttu-id="cb66a-132">在这种情况下，捕获错误只是为了抑制它。</span><span class="sxs-lookup"><span data-stu-id="cb66a-132">This is when you catch an error just to suppress it.</span></span> <span data-ttu-id="cb66a-133">这样做时要谨慎，因为它会使故障排除变得非常困难。</span><span class="sxs-lookup"><span data-stu-id="cb66a-133">Do this with caution because it can make troubleshooting issues very difficult.</span></span>

## <a name="basic-command-syntax"></a><span data-ttu-id="cb66a-134">基本命令语法</span><span class="sxs-lookup"><span data-stu-id="cb66a-134">Basic command syntax</span></span>

<span data-ttu-id="cb66a-135">下面简要概述了 PowerShell 中使用的基本异常处理语法。</span><span class="sxs-lookup"><span data-stu-id="cb66a-135">Here is a quick overview of the basic exception handling syntax used in PowerShell.</span></span>

### <a name="throw"></a><span data-ttu-id="cb66a-136">Throw</span><span class="sxs-lookup"><span data-stu-id="cb66a-136">Throw</span></span>

<span data-ttu-id="cb66a-137">若要创建自己的异常事件，请使用 `throw` 关键字引发异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-137">To create our own exception event, we throw an exception with the `throw` keyword.</span></span>

```powershell
function Start-Something
{
    throw "Bad thing happened"
}
```

<span data-ttu-id="cb66a-138">这会创建一个属于终止错误的运行时异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-138">This creates a runtime exception that is a terminating error.</span></span> <span data-ttu-id="cb66a-139">它由调用函数中的 `catch` 进行处理，或者退出脚本，并显示如下消息：</span><span class="sxs-lookup"><span data-stu-id="cb66a-139">It's handled by a `catch` in a calling function or exits the script with a message like this.</span></span>

```powershell
PS> Start-Something

Bad thing happened
At line:1 char:1
+ throw "Bad thing happened"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (Bad thing happened:String) [], RuntimeException
    + FullyQualifiedErrorId : Bad thing happened
```

#### <a name="write-error--erroraction-stop"></a><span data-ttu-id="cb66a-140">Write-Error -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="cb66a-140">Write-Error -ErrorAction Stop</span></span>

<span data-ttu-id="cb66a-141">我提到过，默认情况下 `Write-Error` 不会引发终止错误。</span><span class="sxs-lookup"><span data-stu-id="cb66a-141">I mentioned that `Write-Error` doesn't throw a terminating error by default.</span></span> <span data-ttu-id="cb66a-142">如果指定 `-ErrorAction Stop`，`Write-Error` 会生成一个可使用 `catch` 处理的终止错误。</span><span class="sxs-lookup"><span data-stu-id="cb66a-142">If you specify `-ErrorAction Stop`, `Write-Error` generates a terminating error that can be handled with a `catch`.</span></span>

```powershell
Write-Error -Message "Houston, we have a problem." -ErrorAction Stop
```

<span data-ttu-id="cb66a-143">感谢 Lee Dailey 提醒我可以这样使用 `-ErrorAction Stop`。</span><span class="sxs-lookup"><span data-stu-id="cb66a-143">Thank you to Lee Dailey for reminding about using `-ErrorAction Stop` this way.</span></span>

#### <a name="cmdlet--erroraction-stop"></a><span data-ttu-id="cb66a-144">Cmdlet -ErrorAction Stop</span><span class="sxs-lookup"><span data-stu-id="cb66a-144">Cmdlet -ErrorAction Stop</span></span>

<span data-ttu-id="cb66a-145">如果在任何高级函数或 cmdlet 上指定 `-ErrorAction Stop`，它会把所有 `Write-Error` 语句转为终止错误，这些错误会使执行停止或可由 `catch` 处理。</span><span class="sxs-lookup"><span data-stu-id="cb66a-145">If you specify `-ErrorAction Stop` on any advanced function or cmdlet, it turns all `Write-Error` statements into terminating errors that stop execution or that can be handled by a `catch`.</span></span>

```powershell
Start-Something -ErrorAction Stop
```

### <a name="trycatch"></a><span data-ttu-id="cb66a-146">Try/Catch</span><span class="sxs-lookup"><span data-stu-id="cb66a-146">Try/Catch</span></span>

<span data-ttu-id="cb66a-147">PowerShell（以及许多其他语言）中的异常处理方式是，先对一部分代码执行 `try`，如果引发错误，则对其执行 `catch`。</span><span class="sxs-lookup"><span data-stu-id="cb66a-147">The way exception handling works in PowerShell (and many other languages) is that you first `try` a section of code and if it throws an error, you can `catch` it.</span></span> <span data-ttu-id="cb66a-148">下面是一个简单的例子。</span><span class="sxs-lookup"><span data-stu-id="cb66a-148">Here is a quick sample.</span></span>

```powershell
try
{
    Start-Something
}
catch
{
    Write-Output "Something threw an exception"
}

try
{
    Start-Something -ErrorAction Stop
}
catch
{
    Write-Output "Something threw an exception or used Write-Error"
}
```

<span data-ttu-id="cb66a-149">`catch` 脚本仅在出现终止错误时才会运行。</span><span class="sxs-lookup"><span data-stu-id="cb66a-149">The `catch` script only runs if there's a terminating error.</span></span> <span data-ttu-id="cb66a-150">如果 `try` 正确执行，则会跳过 `catch`。</span><span class="sxs-lookup"><span data-stu-id="cb66a-150">If the `try` executes correctly, then it skips over the `catch`.</span></span>

### <a name="tryfinally"></a><span data-ttu-id="cb66a-151">Try/Finally</span><span class="sxs-lookup"><span data-stu-id="cb66a-151">Try/Finally</span></span>

<span data-ttu-id="cb66a-152">有时，你不需要处理错误，但无论异常是否发生，仍需要执行一些代码。</span><span class="sxs-lookup"><span data-stu-id="cb66a-152">Sometimes you don't need to handle an error but still need some code to execute if an exception happens or not.</span></span> <span data-ttu-id="cb66a-153">`finally` 脚本正是做的这一点。</span><span class="sxs-lookup"><span data-stu-id="cb66a-153">A `finally` script does exactly that.</span></span>

<span data-ttu-id="cb66a-154">请看下面的示例：</span><span class="sxs-lookup"><span data-stu-id="cb66a-154">Take a look at this example:</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
$command.Connection.Open()
$command.ExecuteNonQuery()
$command.Connection.Close()
```

<span data-ttu-id="cb66a-155">无论何时打开或连接到资源，都应将其关闭。</span><span class="sxs-lookup"><span data-stu-id="cb66a-155">Anytime you open or connect to a resource, you should close it.</span></span> <span data-ttu-id="cb66a-156">如果 `ExecuteNonQuery()` 引发异常，则连接不会关闭。</span><span class="sxs-lookup"><span data-stu-id="cb66a-156">If the `ExecuteNonQuery()` throws an exception, the connection isn't closed.</span></span> <span data-ttu-id="cb66a-157">下面是 `try/finally` 块内的相同代码。</span><span class="sxs-lookup"><span data-stu-id="cb66a-157">Here is the same code inside a `try/finally` block.</span></span>

```powershell
$command = [System.Data.SqlClient.SqlCommand]::New(queryString, connection)
try
{
    $command.Connection.Open()
    $command.ExecuteNonQuery()
}
finally
{
    $command.Connection.Close()
}
```

<span data-ttu-id="cb66a-158">在本例中，如果出现错误，则连接关闭。</span><span class="sxs-lookup"><span data-stu-id="cb66a-158">In this example, the connection is closed if there's an error.</span></span> <span data-ttu-id="cb66a-159">如果没有错误，也会将其关闭。</span><span class="sxs-lookup"><span data-stu-id="cb66a-159">It also is closed if there's no error.</span></span> <span data-ttu-id="cb66a-160">每次都会运行 `finally` 脚本。</span><span class="sxs-lookup"><span data-stu-id="cb66a-160">The `finally` script runs every time.</span></span>

<span data-ttu-id="cb66a-161">由于未捕获异常，它仍会在调用堆栈中向上传播。</span><span class="sxs-lookup"><span data-stu-id="cb66a-161">Because you're not catching the exception, it still gets propagated up the call stack.</span></span>

### <a name="trycatchfinally"></a><span data-ttu-id="cb66a-162">Try/Catch/Finally</span><span class="sxs-lookup"><span data-stu-id="cb66a-162">Try/Catch/Finally</span></span>

<span data-ttu-id="cb66a-163">同时使用 `catch` 和 `finally` 是非常有效的。</span><span class="sxs-lookup"><span data-stu-id="cb66a-163">It's perfectly valid to use `catch` and `finally` together.</span></span> <span data-ttu-id="cb66a-164">大多数情况下，你将使用其中一个，但也可能会有两种都使用的情况。</span><span class="sxs-lookup"><span data-stu-id="cb66a-164">Most of the time you'll use one or the other, but you may find scenarios where you use both.</span></span>

## <a name="psitem"></a><span data-ttu-id="cb66a-165">$PSItem</span><span class="sxs-lookup"><span data-stu-id="cb66a-165">$PSItem</span></span>

<span data-ttu-id="cb66a-166">现在我们已经了解了基本知识，下面可以更深入地了解。</span><span class="sxs-lookup"><span data-stu-id="cb66a-166">Now that we got the basics out of the way, we can dig a little deeper.</span></span>

<span data-ttu-id="cb66a-167">在 `catch` 块内，有一个类型为 `ErrorRecord` 的自动变量（`$PSItem` 或 `$_`），其中包含有关异常的详细信息。</span><span class="sxs-lookup"><span data-stu-id="cb66a-167">Inside the `catch` block, there's an automatic variable (`$PSItem` or `$_`) of type `ErrorRecord` that contains the details about the exception.</span></span> <span data-ttu-id="cb66a-168">下面是一些关键属性的简要概述。</span><span class="sxs-lookup"><span data-stu-id="cb66a-168">Here is a quick overview of some of the key properties.</span></span>

<span data-ttu-id="cb66a-169">对于这些示例，我在 `ReadAllText` 中使用了一个无效路径来生成此异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-169">For these examples, I used an invalid path in `ReadAllText` to generate this exception.</span></span>

```powershell
[System.IO.File]::ReadAllText( '\\test\no\filefound.log')
```

### <a name="psitemtostring"></a><span data-ttu-id="cb66a-170">PSItem.ToString()</span><span class="sxs-lookup"><span data-stu-id="cb66a-170">PSItem.ToString()</span></span>

<span data-ttu-id="cb66a-171">这为你提供了最简洁的消息来用于日志记录和常规输出。</span><span class="sxs-lookup"><span data-stu-id="cb66a-171">This gives you the cleanest message to use in logging and general output.</span></span> <span data-ttu-id="cb66a-172">如果将 `$PSItem` 放在字符串中，将自动调用 `ToString()`。</span><span class="sxs-lookup"><span data-stu-id="cb66a-172">`ToString()` is automatically called if `$PSItem` is placed inside a string.</span></span>

```powershell
catch
{
    Write-Output "Ran into an issue: $($PSItem.ToString())"
}

catch
{
    Write-Output "Ran into an issue: $PSItem"
}
```

### <a name="psiteminvocationinfo"></a><span data-ttu-id="cb66a-173">$PSItem.InvocationInfo</span><span class="sxs-lookup"><span data-stu-id="cb66a-173">$PSItem.InvocationInfo</span></span>

<span data-ttu-id="cb66a-174">此属性包含 PowerShell 收集的有关引发异常的函数或脚本的其他信息。</span><span class="sxs-lookup"><span data-stu-id="cb66a-174">This property contains additional information collected by PowerShell about the function or script where the exception was thrown.</span></span> <span data-ttu-id="cb66a-175">下面是我创建的示例异常中的 `InvocationInfo`。</span><span class="sxs-lookup"><span data-stu-id="cb66a-175">Here is the `InvocationInfo` from the sample exception that I created.</span></span>

```powershell
PS> $PSItem.InvocationInfo | Format-List *

MyCommand             : Get-Resource
BoundParameters       : {}
UnboundArguments      : {}
ScriptLineNumber      : 5
OffsetInLine          : 5
ScriptName            : C:\blog\throwerror.ps1
Line                  :     Get-Resource
PositionMessage       : At C:\blog\throwerror.ps1:5 char:5
                        +     Get-Resource
                        +     ~~~~~~~~~~~~
PSScriptRoot          : C:\blog
PSCommandPath         : C:\blog\throwerror.ps1
InvocationName        : Get-Resource
```

<span data-ttu-id="cb66a-176">此处的重要详细信息显示了 `ScriptName`、代码 `Line` 和调用开始时的 `ScriptLineNumber`。</span><span class="sxs-lookup"><span data-stu-id="cb66a-176">The important details here show the `ScriptName`, the `Line` of code and the `ScriptLineNumber` where the invocation started.</span></span>

### <a name="psitemscriptstacktrace"></a><span data-ttu-id="cb66a-177">$PSItem.ScriptStackTrace</span><span class="sxs-lookup"><span data-stu-id="cb66a-177">$PSItem.ScriptStackTrace</span></span>

<span data-ttu-id="cb66a-178">此属性显示函数调用顺序，这些函数调用会将你带到生成异常的代码。</span><span class="sxs-lookup"><span data-stu-id="cb66a-178">This property shows the order of function calls that got you to the code where the exception was generated.</span></span>

```powershell
PS> $PSItem.ScriptStackTrace
at Get-Resource, C:\blog\throwerror.ps1: line 13
at Start-Something, C:\blog\throwerror.ps1: line 5
at <ScriptBlock>, C:\blog\throwerror.ps1: line 18
```

<span data-ttu-id="cb66a-179">我只调用同一脚本中的函数，但如果涉及多个脚本，则会跟踪调用。</span><span class="sxs-lookup"><span data-stu-id="cb66a-179">I'm only making calls to functions in the same script but this would track the calls if multiple scripts were involved.</span></span>

### <a name="psitemexception"></a><span data-ttu-id="cb66a-180">$PSItem.Exception</span><span class="sxs-lookup"><span data-stu-id="cb66a-180">$PSItem.Exception</span></span>

<span data-ttu-id="cb66a-181">这是实际引发的异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-181">This is the actual exception that was thrown.</span></span>

#### <a name="psitemexceptionmessage"></a><span data-ttu-id="cb66a-182">$PSItem.Exception.Message</span><span class="sxs-lookup"><span data-stu-id="cb66a-182">$PSItem.Exception.Message</span></span>

<span data-ttu-id="cb66a-183">这是描述异常的一般消息，在进行故障排除时，这是一个很好的起点。</span><span class="sxs-lookup"><span data-stu-id="cb66a-183">This is the general message that describes the exception and is a good starting point when troubleshooting.</span></span> <span data-ttu-id="cb66a-184">大多数异常都有默认消息，但也可以在引发异常时设置自定义消息。</span><span class="sxs-lookup"><span data-stu-id="cb66a-184">Most exceptions have a default message but can also be set to something custom when the exception is thrown.</span></span>

```powershell
PS> $PSItem.Exception.Message

Exception calling "ReadAllText" with "1" argument(s): "The network path was not found."
```

<span data-ttu-id="cb66a-185">这也是在调用 `$PSItem.ToString()` 时返回的消息（如果未在 `ErrorRecord` 中设置）。</span><span class="sxs-lookup"><span data-stu-id="cb66a-185">This is also the message returned when calling `$PSItem.ToString()` if there was not one set on the `ErrorRecord`.</span></span>

#### <a name="psitemexceptioninnerexception"></a><span data-ttu-id="cb66a-186">$PSItem.Exception.InnerException</span><span class="sxs-lookup"><span data-stu-id="cb66a-186">$PSItem.Exception.InnerException</span></span>

<span data-ttu-id="cb66a-187">异常可能包含内部异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-187">Exceptions can contain inner exceptions.</span></span> <span data-ttu-id="cb66a-188">当调用的代码捕获异常并引发其他异常时，通常会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="cb66a-188">This is often the case when the code you're calling catches an exception and throws a different exception.</span></span> <span data-ttu-id="cb66a-189">原始异常放置在新异常中。</span><span class="sxs-lookup"><span data-stu-id="cb66a-189">The original exception is placed inside the new exception.</span></span>

```powershell
PS> $PSItem.Exception.InnerExceptionMessage
The network path was not found.
```

<span data-ttu-id="cb66a-190">稍后讨论重新引发异常时我会回顾此内容。</span><span class="sxs-lookup"><span data-stu-id="cb66a-190">I will revisit this later when I talk about re-throwing exceptions.</span></span>

#### <a name="psitemexceptionstacktrace"></a><span data-ttu-id="cb66a-191">$PSItem.Exception.StackTrace</span><span class="sxs-lookup"><span data-stu-id="cb66a-191">$PSItem.Exception.StackTrace</span></span>

<span data-ttu-id="cb66a-192">这是面向异常的 `StackTrace`。</span><span class="sxs-lookup"><span data-stu-id="cb66a-192">This is the `StackTrace` for the exception.</span></span> <span data-ttu-id="cb66a-193">我在上文展示了 `ScriptStackTrace`，但这个属性适用于对托管代码的调用。</span><span class="sxs-lookup"><span data-stu-id="cb66a-193">I showed a `ScriptStackTrace` above, but this one is for the calls to managed code.</span></span>

```Output
at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean
 useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs,
 String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32
 bufferSize, FileOptions options, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean
 checkHost)
at System.IO.StreamReader..ctor(String path, Encoding encoding, Boolean detectEncodingFromByteOrderMarks,
 Int32 bufferSize, Boolean checkHost)
at System.IO.File.InternalReadAllText(String path, Encoding encoding, Boolean checkHost)
at CallSite.Target(Closure , CallSite , Type , String )
```

<span data-ttu-id="cb66a-194">仅当从托管代码引发事件时，才会获取此堆栈跟踪。</span><span class="sxs-lookup"><span data-stu-id="cb66a-194">You only get this stack trace when the event is thrown from managed code.</span></span> <span data-ttu-id="cb66a-195">我直接调用了 .NET Framework 函数，因此这就是我们在本例中可以看到的所有内容。</span><span class="sxs-lookup"><span data-stu-id="cb66a-195">I'm calling a .NET framework function directly so that is all we can see in this example.</span></span> <span data-ttu-id="cb66a-196">通常，当你查看堆栈跟踪时，你是在寻找代码停止以及系统调用开始的位置。</span><span class="sxs-lookup"><span data-stu-id="cb66a-196">Generally when you're looking at a stack trace, you're looking for where your code stops and the system calls begin.</span></span>

## <a name="working-with-exceptions"></a><span data-ttu-id="cb66a-197">处理异常</span><span class="sxs-lookup"><span data-stu-id="cb66a-197">Working with exceptions</span></span>

<span data-ttu-id="cb66a-198">除了基本语法和异常属性以外，异常还有很有内容。</span><span class="sxs-lookup"><span data-stu-id="cb66a-198">There is more to exceptions than the basic syntax and exception properties.</span></span>

### <a name="catching-typed-exceptions"></a><span data-ttu-id="cb66a-199">捕获类型化异常</span><span class="sxs-lookup"><span data-stu-id="cb66a-199">Catching typed exceptions</span></span>

<span data-ttu-id="cb66a-200">你可以有选择地处理捕获的异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-200">You can be selective with the exceptions that you catch.</span></span> <span data-ttu-id="cb66a-201">异常具有类型，你可以指定要捕获的异常类型。</span><span class="sxs-lookup"><span data-stu-id="cb66a-201">Exceptions have a type and you can specify the type of exception you want to catch.</span></span>

```powershell
try
{
    Start-Something -Path $path
}
catch [System.IO.FileNotFoundException]
{
    Write-Output "Could not find $path"
}
catch [System.IO.IOException]
{
        Write-Output "IO error with the file: $path"
}
```

<span data-ttu-id="cb66a-202">针对每个 `catch` 块检查异常类型，直到找到与你的异常匹配的块。</span><span class="sxs-lookup"><span data-stu-id="cb66a-202">The exception type is checked for each `catch` block until one is found that matches your exception.</span></span>
<span data-ttu-id="cb66a-203">必须认识到，异常可继承自其他异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-203">It's important to realize that exceptions can inherit from other exceptions.</span></span> <span data-ttu-id="cb66a-204">在上面的示例中，`FileNotFoundException` 继承自 `IOException`。</span><span class="sxs-lookup"><span data-stu-id="cb66a-204">In the example above, `FileNotFoundException` inherits from `IOException`.</span></span> <span data-ttu-id="cb66a-205">因此，如果 `IOException` 在前，则会改为调用它。</span><span class="sxs-lookup"><span data-stu-id="cb66a-205">So if the `IOException` was first, then it would get called instead.</span></span> <span data-ttu-id="cb66a-206">即使有多个匹配项，也只调用一个 catch 块。</span><span class="sxs-lookup"><span data-stu-id="cb66a-206">Only one catch block is invoked even if there are multiple matches.</span></span>

<span data-ttu-id="cb66a-207">如果有 `System.IO.PathTooLongException`，则 `IOException` 会匹配，但如果有 `InsufficientMemoryException`，则不会捕获到它，它会向上传播堆栈。</span><span class="sxs-lookup"><span data-stu-id="cb66a-207">If we had a `System.IO.PathTooLongException`, the `IOException` would match but if we had a `InsufficientMemoryException` then nothing would catch it and it would propagate up the stack.</span></span>

### <a name="catch-multiple-types-at-once"></a><span data-ttu-id="cb66a-208">一次捕获多种类型</span><span class="sxs-lookup"><span data-stu-id="cb66a-208">Catch multiple types at once</span></span>

<span data-ttu-id="cb66a-209">可以用相同的 `catch` 语句来捕获多个异常类型。</span><span class="sxs-lookup"><span data-stu-id="cb66a-209">It's possible to catch multiple exception types with the same `catch` statement.</span></span>

```powershell
try
{
    Start-Something -Path $path -ErrorAction Stop
}
catch [System.IO.DirectoryNotFoundException],[System.IO.FileNotFoundException]
{
    Write-Output "The path or file was not found: [$path]"
}
catch [System.IO.IOException]
{
    Write-Output "IO error with the file: [$path]"
}
```

<span data-ttu-id="cb66a-210">感谢 `/u/Sheppard_Ra` 建议添加此内容。</span><span class="sxs-lookup"><span data-stu-id="cb66a-210">Thank you `/u/Sheppard_Ra` for suggesting this addition.</span></span>

### <a name="throwing-typed-exceptions"></a><span data-ttu-id="cb66a-211">引发类型化异常</span><span class="sxs-lookup"><span data-stu-id="cb66a-211">Throwing typed exceptions</span></span>

<span data-ttu-id="cb66a-212">可以在 PowerShell 中引发类型化异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-212">You can throw typed exceptions in PowerShell.</span></span> <span data-ttu-id="cb66a-213">不要使用字符串调用 `throw`：</span><span class="sxs-lookup"><span data-stu-id="cb66a-213">Instead of calling `throw` with a string:</span></span>

```powershell
throw "Could not find: $path"
```

<span data-ttu-id="cb66a-214">使用如下所示的异常加速器：</span><span class="sxs-lookup"><span data-stu-id="cb66a-214">Use an exception accelerator like this:</span></span>

```powershell
throw [System.IO.FileNotFoundException] "Could not find: $path"
```

<span data-ttu-id="cb66a-215">但在这样做时必须指定一条消息。</span><span class="sxs-lookup"><span data-stu-id="cb66a-215">But you have to specify a message when you do it that way.</span></span>

<span data-ttu-id="cb66a-216">你还可以创建要引发的异常的新实例。</span><span class="sxs-lookup"><span data-stu-id="cb66a-216">You can also create a new instance of an exception to be thrown.</span></span> <span data-ttu-id="cb66a-217">这样做时，消息是可选的，因为系统对所有内置异常都有默认消息。</span><span class="sxs-lookup"><span data-stu-id="cb66a-217">The message is optional when you do this because the system has default messages for all built-in exceptions.</span></span>

```powershell
throw [System.IO.FileNotFoundException]::new()
throw [System.IO.FileNotFoundException]::new("Could not find path: $path")
```

<span data-ttu-id="cb66a-218">如果未使用 PowerShell 5.0 或更高版本，则必须使用较旧的 `New-Object` 方法。</span><span class="sxs-lookup"><span data-stu-id="cb66a-218">If you're not using PowerShell 5.0 or higher, you must use the older `New-Object` approach.</span></span>

```powershell
throw (New-Object -TypeName System.IO.FileNotFoundException )
throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList "Could not find path: $path")
```

<span data-ttu-id="cb66a-219">通过使用类型化异常，你（或其他人）可以按上一部分提到的类型捕获异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-219">By using a typed exception, you (or others) can catch the exception by the type as mentioned in the previous section.</span></span>

#### <a name="write-error--exception"></a><span data-ttu-id="cb66a-220">Write-Error -Exception</span><span class="sxs-lookup"><span data-stu-id="cb66a-220">Write-Error -Exception</span></span>

<span data-ttu-id="cb66a-221">我们可以将这些类型化异常添加到 `Write-Error` 中，我们仍然可以按异常类型来 `catch` 错误。</span><span class="sxs-lookup"><span data-stu-id="cb66a-221">We can add these typed exceptions to `Write-Error` and we can still `catch` the errors by exception type.</span></span> <span data-ttu-id="cb66a-222">使用 `Write-Error`，如以下示例所示：</span><span class="sxs-lookup"><span data-stu-id="cb66a-222">Use `Write-Error` like in these examples:</span></span>

```powershell
# with normal message
Write-Error -Message "Could not find path: $path" -Exception ([System.IO.FileNotFoundException]::new()) -ErrorAction Stop

# With message inside new exception
Write-Error -Exception ([System.IO.FileNotFoundException]::new("Could not find path: $path")) -ErrorAction Stop

# Pre PS 5.0
Write-Error -Exception ([System.IO.FileNotFoundException]"Could not find path: $path") -ErrorAction Stop

Write-Error -Message "Could not find path: $path" -Exception ( New-Object -TypeName System.IO.FileNotFoundException ) -ErrorAction Stop
```

<span data-ttu-id="cb66a-223">接下来，我们可以像这样捕获它：</span><span class="sxs-lookup"><span data-stu-id="cb66a-223">Then we can catch it like this:</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Log $PSItem.ToString()
}
```

#### <a name="the-big-list-of-net-exceptions"></a><span data-ttu-id="cb66a-224">.NET 异常大列表</span><span class="sxs-lookup"><span data-stu-id="cb66a-224">The big list of .NET exceptions</span></span>

<span data-ttu-id="cb66a-225">在 [Reddit/r/PowerShell 社区][]的帮助下，我编译了一个包含数百个 .NET 异常的总览表，作为对本文的补充。</span><span class="sxs-lookup"><span data-stu-id="cb66a-225">I compiled a master list with the help of the [Reddit/r/PowerShell community][] that contains hundreds of .NET exceptions to complement this post.</span></span>

- <span data-ttu-id="cb66a-226">[.NET 异常大列表][]</span><span class="sxs-lookup"><span data-stu-id="cb66a-226">[The big list of .NET exceptions][]</span></span>

<span data-ttu-id="cb66a-227">我首先在列表中搜索那些感觉适合我当前情况的异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-227">I start by searching that list for exceptions that feel like they would be a good fit for my situation.</span></span> <span data-ttu-id="cb66a-228">你应尝试在基本 `System` 命名空间中使用异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-228">You should try to use exceptions in the base `System` namespace.</span></span>

### <a name="exceptions-are-objects"></a><span data-ttu-id="cb66a-229">异常为对象</span><span class="sxs-lookup"><span data-stu-id="cb66a-229">Exceptions are objects</span></span>

<span data-ttu-id="cb66a-230">当你开始大量使用类型化异常时，请记住它们是对象。</span><span class="sxs-lookup"><span data-stu-id="cb66a-230">If you start using a lot of typed exceptions, remember that they are objects.</span></span> <span data-ttu-id="cb66a-231">不同的异常具有不同的构造函数和属性。</span><span class="sxs-lookup"><span data-stu-id="cb66a-231">Different exceptions have different constructors and properties.</span></span> <span data-ttu-id="cb66a-232">如果查看 [FileNotFoundException][] 文档中的 `System.IO.FileNotFoundException`，我们就会知道可以传入消息和文件路径。</span><span class="sxs-lookup"><span data-stu-id="cb66a-232">If we look at the [FileNotFoundException][] documentation for `System.IO.FileNotFoundException`, we see that we can pass in a message and a file path.</span></span>

```powershell
[System.IO.FileNotFoundException]::new("Could not find file", $path)
```

<span data-ttu-id="cb66a-233">它具有公开该文件路径的 `FileName` 属性。</span><span class="sxs-lookup"><span data-stu-id="cb66a-233">And it has a `FileName` property that exposes that file path.</span></span>

```powershell
catch [System.IO.FileNotFoundException]
{
    Write-Output $PSItem.Exception.FileName
}
```

<span data-ttu-id="cb66a-234">若要了解其他构造函数和对象属性，应参阅 [.NET 文档][]。</span><span class="sxs-lookup"><span data-stu-id="cb66a-234">You should consult the [.NET documentation][] for other constructors and object properties.</span></span>

### <a name="re-throwing-an-exception"></a><span data-ttu-id="cb66a-235">重新引发异常</span><span class="sxs-lookup"><span data-stu-id="cb66a-235">Re-throwing an exception</span></span>

<span data-ttu-id="cb66a-236">如果在 `catch` 块中要做的只是 `throw` 同一个异常，那么就不要 `catch` 它。</span><span class="sxs-lookup"><span data-stu-id="cb66a-236">If all you're going to do in your `catch` block is `throw` the same exception, then don't `catch` it.</span></span> <span data-ttu-id="cb66a-237">在发生异常时，应仅对计划处理的异常执行 `catch` 或某些操作。</span><span class="sxs-lookup"><span data-stu-id="cb66a-237">You should only `catch` an exception that you plan to handle or perform some action when it happens.</span></span>

<span data-ttu-id="cb66a-238">有时，你需要对异常执行操作，但要重新引发异常，以便下游能够处理该异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-238">There are times where you want to perform an action on an exception but re-throw the exception so something downstream can deal with it.</span></span> <span data-ttu-id="cb66a-239">我们可以在发现问题的位置附近编写消息或记录问题，但在堆栈的更上层处理问题。</span><span class="sxs-lookup"><span data-stu-id="cb66a-239">We could write a message or log the problem close to where we discover it but handle the issue further up the stack.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw $PSItem
}
```

<span data-ttu-id="cb66a-240">有趣的是，我们可以从 `catch` 内调用 `throw`，它会重新引发当前异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-240">Interestingly enough, we can call `throw` from within the `catch` and it re-throws the current exception.</span></span>

```powershell
catch
{
    Write-Log $PSItem.ToString()
    throw
}
```

<span data-ttu-id="cb66a-241">我们想要重新引发异常，以保留原始执行信息，如源脚本和行号。</span><span class="sxs-lookup"><span data-stu-id="cb66a-241">We want to re-throw the exception to preserve the original execution information like source script and line number.</span></span> <span data-ttu-id="cb66a-242">如果此时引发新异常，它将隐藏异常开始的位置。</span><span class="sxs-lookup"><span data-stu-id="cb66a-242">If we throw a new exception at this point, it hides where the exception started.</span></span>

#### <a name="re-throwing-a-new-exception"></a><span data-ttu-id="cb66a-243">重新引发新异常</span><span class="sxs-lookup"><span data-stu-id="cb66a-243">Re-throwing a new exception</span></span>

<span data-ttu-id="cb66a-244">如果捕获到一个异常，但想要引发另一个异常，则应将原始异常嵌套在新异常内。</span><span class="sxs-lookup"><span data-stu-id="cb66a-244">If you catch an exception but you want to throw a different one, then you should nest the original exception inside the new one.</span></span> <span data-ttu-id="cb66a-245">这样一来，堆栈下游的人就可以将其作为 `$PSItem.Exception.InnerException` 进行访问。</span><span class="sxs-lookup"><span data-stu-id="cb66a-245">This allows someone down the stack to access it as the `$PSItem.Exception.InnerException`.</span></span>

```powershell
catch
{
    throw [System.MissingFieldException]::new('Could not access field',$PSItem.Exception)
}
```

#### <a name="pscmdletthrowterminatingerror"></a><span data-ttu-id="cb66a-246">$PSCmdlet.ThrowTerminatingError()</span><span class="sxs-lookup"><span data-stu-id="cb66a-246">$PSCmdlet.ThrowTerminatingError()</span></span>

<span data-ttu-id="cb66a-247">我不喜欢对原始异常使用 `throw` 的一个原因是，错误消息指向 `throw` 语句，并指示该行是问题所在。</span><span class="sxs-lookup"><span data-stu-id="cb66a-247">The one thing that I don't like about using `throw` for raw exceptions is that the error message points at the `throw` statement and indicates that line is where the problem is.</span></span>

```Output
Unable to find the specified file.
At line:31 char:9
+         throw [System.IO.FileNotFoundException]::new()
+         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : OperationStopped: (:) [], FileNotFoundException
    + FullyQualifiedErrorId : Unable to find the specified file.
```

<span data-ttu-id="cb66a-248">让错误消息告诉我脚本已损坏，因为我在第 31 行调用了 `throw`，这对于你的脚本用户来说是一个坏消息。</span><span class="sxs-lookup"><span data-stu-id="cb66a-248">Having the error message tell me that my script is broken because I called `throw` on line 31 is a bad message for users of your script to see.</span></span> <span data-ttu-id="cb66a-249">它没有提供任何有用的内容。</span><span class="sxs-lookup"><span data-stu-id="cb66a-249">It doesn't tell them anything useful.</span></span>

<span data-ttu-id="cb66a-250">Dexter Dhami 指出，我可以使用 `ThrowTerminatingError()` 来纠正此问题。</span><span class="sxs-lookup"><span data-stu-id="cb66a-250">Dexter Dhami pointed out that I can use `ThrowTerminatingError()` to correct that.</span></span>

```powershell
$PSCmdlet.ThrowTerminatingError(
    [System.Management.Automation.ErrorRecord]::new(
        ([System.IO.FileNotFoundException]"Could not find $Path"),
        'My.ID',
        [System.Management.Automation.ErrorCategory]::OpenError,
        $MyObject
    )
)
```

<span data-ttu-id="cb66a-251">如果假定在名为 `Get-Resource` 的函数中调用了 `ThrowTerminatingError()`，那么以下就是我们将会看到的错误。</span><span class="sxs-lookup"><span data-stu-id="cb66a-251">If we assume that `ThrowTerminatingError()` was called inside a function called `Get-Resource`, then this is the error that we would see.</span></span>

```Output
Get-Resource : Could not find C:\Program Files (x86)\Reference
Assemblies\Microsoft\Framework\.NETPortable\v4.6\System.IO.xml
At line:6 char:5
+     Get-Resource -Path $Path
+     ~~~~~~~~~~~~
    + CategoryInfo          : OpenError: (:) [Get-Resource], FileNotFoundException
    + FullyQualifiedErrorId : My.ID,Get-Resource
```

<span data-ttu-id="cb66a-252">你是否明白它如何指向 `Get-Resource` 函数作为问题来源？</span><span class="sxs-lookup"><span data-stu-id="cb66a-252">Do you see how it points to the `Get-Resource` function as the source of the problem?</span></span> <span data-ttu-id="cb66a-253">这会告诉用户一些有用的信息。</span><span class="sxs-lookup"><span data-stu-id="cb66a-253">That tells the user something useful.</span></span>

<span data-ttu-id="cb66a-254">由于 `$PSItem` 是 `ErrorRecord`，因此还可以使用 `ThrowTerminatingError` 以这种方式重新引发。</span><span class="sxs-lookup"><span data-stu-id="cb66a-254">Because `$PSItem` is an `ErrorRecord`, we can also use `ThrowTerminatingError` this way to re-throw.</span></span>

```powershell
catch
{
    $PSCmdlet.ThrowTerminatingError($PSItem)
}
```

<span data-ttu-id="cb66a-255">这会将错误源更改为 Cmdlet，并向 Cmdlet 用户隐藏函数内部信息。</span><span class="sxs-lookup"><span data-stu-id="cb66a-255">This changes the source of the error to the Cmdlet and hide the internals of your function from the users of your Cmdlet.</span></span>

## <a name="try-can-create-terminating-errors"></a><span data-ttu-id="cb66a-256">Try 可能会创建终止错误</span><span class="sxs-lookup"><span data-stu-id="cb66a-256">Try can create terminating errors</span></span>

<span data-ttu-id="cb66a-257">Kirk Munro 指出，某些异常仅在 `try/catch` 块内执行时为终止错误。</span><span class="sxs-lookup"><span data-stu-id="cb66a-257">Kirk Munro points out that some exceptions are only terminating errors when executed inside a `try/catch` block.</span></span> <span data-ttu-id="cb66a-258">下面是他为我提供的一个示例，其中生成了一个除以零的运行时异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-258">Here is the example he gave me that generates a divide by zero runtime exception.</span></span>

```powershell
function Start-Something { 1/(1-1) }
```

<span data-ttu-id="cb66a-259">然后像这样调用它，可以看到它生成错误并仍然输出消息。</span><span class="sxs-lookup"><span data-stu-id="cb66a-259">Then invoke it like this to see it generate the error and still output the message.</span></span>

```powershell
&{ Start-Something; Write-Output "We did it. Send Email" }
```

<span data-ttu-id="cb66a-260">但通过在 `try/catch` 中放置相同代码，我们可以看到发生了一些别的情况。</span><span class="sxs-lookup"><span data-stu-id="cb66a-260">But by placing that same code inside a `try/catch`, we see something else happen.</span></span>

```powershell
try
{
    &{ Start-Something; Write-Output "We did it. Send Email" }
}
catch
{
    Write-Output "Notify Admin to fix error and send email"
}
```

<span data-ttu-id="cb66a-261">我们看到错误变成终止错误，且没有输出第一条消息。</span><span class="sxs-lookup"><span data-stu-id="cb66a-261">We see the error become a terminating error and not output the first message.</span></span> <span data-ttu-id="cb66a-262">我不喜欢这个的原因是，你可以在函数中使用此代码，如果用户使用 `try/catch`，则其行为方式会不同。</span><span class="sxs-lookup"><span data-stu-id="cb66a-262">What I don't like about this one is that you can have this code in a function and it acts differently if someone is using a `try/catch`.</span></span>

<span data-ttu-id="cb66a-263">我自己尚未遇到这方面的问题，但这是需要注意的极端情况。</span><span class="sxs-lookup"><span data-stu-id="cb66a-263">I have not ran into issues with this myself but it is corner case to be aware of.</span></span>

### <a name="pscmdletthrowterminatingerror-inside-trycatch"></a><span data-ttu-id="cb66a-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span><span class="sxs-lookup"><span data-stu-id="cb66a-264">$PSCmdlet.ThrowTerminatingError() inside try/catch</span></span>

<span data-ttu-id="cb66a-265">`$PSCmdlet.ThrowTerminatingError()` 的一项细微差别在于，它在 Cmdlet 中创建了一个终止错误，但会在离开 Cmdlet 后变成非终止错误。</span><span class="sxs-lookup"><span data-stu-id="cb66a-265">One nuance of `$PSCmdlet.ThrowTerminatingError()` is that it creates a terminating error within your Cmdlet but it turns into a non-terminating error after it leaves your Cmdlet.</span></span> <span data-ttu-id="cb66a-266">这就把决定如何处理错误的负担留给了函数调用者。</span><span class="sxs-lookup"><span data-stu-id="cb66a-266">This leaves the burden on the caller of your function to decide how to handle the error.</span></span> <span data-ttu-id="cb66a-267">它们可以通过使用 `-ErrorAction Stop` 或从 `try{...}catch{...}` 中进行调用来将其转换回终止错误。</span><span class="sxs-lookup"><span data-stu-id="cb66a-267">They can turn it back into a terminating error by using `-ErrorAction Stop` or calling it from within a `try{...}catch{...}`.</span></span>

### <a name="public-function-templates"></a><span data-ttu-id="cb66a-268">公共函数模板</span><span class="sxs-lookup"><span data-stu-id="cb66a-268">Public function templates</span></span>

<span data-ttu-id="cb66a-269">我与 Kirk Munro 谈论的最后一个要点是，他在所有高级函数的每个 `begin`、`process` 和 `end` 块周围放置了 `try{...}catch{...}`。</span><span class="sxs-lookup"><span data-stu-id="cb66a-269">One last take a way I had with my conversation with Kirk Munro was that he places a `try{...}catch{...}` around every `begin`, `process` and `end` block in all of his advanced functions.</span></span> <span data-ttu-id="cb66a-270">在这些泛型 catch 块中，他使用 `$PSCmdlet.ThrowTerminatingError($PSItem)` 作为单个行来处理所有离开函数的异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-270">In those generic catch blocks, he has a single line using `$PSCmdlet.ThrowTerminatingError($PSItem)` to deal with all exceptions leaving his functions.</span></span>

```powershell
function Start-Something
{
    [CmdletBinding()]
    param()

    process
    {
        try
        {
            ...
        }
        catch
        {
            $PSCmdlet.ThrowTerminatingError($PSItem)
        }
    }
}
```

<span data-ttu-id="cb66a-271">由于所有内容都位于其函数内的 `try` 语句中，因此所有内容的行为一致。</span><span class="sxs-lookup"><span data-stu-id="cb66a-271">Because everything is in a `try` statement within his functions, everything acts consistently.</span></span> <span data-ttu-id="cb66a-272">这还会向最终用户提供简洁的错误信息，对生成的错误隐藏内部代码。</span><span class="sxs-lookup"><span data-stu-id="cb66a-272">This also gives clean errors to the end user that hides the internal code from the generated error.</span></span>

## <a name="trap"></a><span data-ttu-id="cb66a-273">Trap</span><span class="sxs-lookup"><span data-stu-id="cb66a-273">Trap</span></span>

<span data-ttu-id="cb66a-274">我将重点放在了异常的 `try/catch` 方面。</span><span class="sxs-lookup"><span data-stu-id="cb66a-274">I focused on the `try/catch` aspect of exceptions.</span></span> <span data-ttu-id="cb66a-275">但在结束之前，我需要提到一项旧功能。</span><span class="sxs-lookup"><span data-stu-id="cb66a-275">But there's one legacy feature I need to mention before we wrap this up.</span></span>

<span data-ttu-id="cb66a-276">将 `trap` 放置在脚本或函数中，可捕获在该作用域内发生的所有异常。</span><span class="sxs-lookup"><span data-stu-id="cb66a-276">A `trap` is placed in a script or function to catch all exceptions that happen in that scope.</span></span> <span data-ttu-id="cb66a-277">发生异常时，将执行 `trap` 中的代码，然后继续执行正常代码。</span><span class="sxs-lookup"><span data-stu-id="cb66a-277">When an exception happens, the code in the `trap` is executed and then the normal code continues.</span></span> <span data-ttu-id="cb66a-278">如果发生多个异常，则会反复调用 trap。</span><span class="sxs-lookup"><span data-stu-id="cb66a-278">If multiple exceptions happen, then the trap is called over and over.</span></span>

```powershell
trap
{
    Write-Log $PSItem.ToString()
}

throw [System.Exception]::new('first')
throw [System.Exception]::new('second')
throw [System.Exception]::new('third')
```

<span data-ttu-id="cb66a-279">我个人从未用过这种方法，但我可以在记录任何和所有异常的管理员或控制器脚本中看到该值，然后仍继续执行。</span><span class="sxs-lookup"><span data-stu-id="cb66a-279">I personally never adopted this approach but I can see the value in admin or controller scripts that log any and all exceptions, then still continue to execute.</span></span>

## <a name="closing-remarks"></a><span data-ttu-id="cb66a-280">结束语</span><span class="sxs-lookup"><span data-stu-id="cb66a-280">Closing remarks</span></span>

<span data-ttu-id="cb66a-281">向脚本添加适当的异常处理不仅使其更稳定，还可以让你更轻松地对异常进行故障排除。</span><span class="sxs-lookup"><span data-stu-id="cb66a-281">Adding proper exception handling to your scripts not only make them more stable, but also makes it easier for you to troubleshoot those exceptions.</span></span>

<span data-ttu-id="cb66a-282">我花了很多时间来谈论 `throw`，因为这是异常处理的一个核心概念。</span><span class="sxs-lookup"><span data-stu-id="cb66a-282">I spent a lot of time talking `throw` because it is a core concept when talking about exception handling.</span></span> <span data-ttu-id="cb66a-283">PowerShell 还向我们提供了 `Write-Error`，它可处理要使用 `throw` 的所有情况。</span><span class="sxs-lookup"><span data-stu-id="cb66a-283">PowerShell also gave us `Write-Error` that handles all the situations where you would use `throw`.</span></span> <span data-ttu-id="cb66a-284">所以，在阅读本文后，不要认为你需要使用 `throw`。</span><span class="sxs-lookup"><span data-stu-id="cb66a-284">So don't think that you need to be using `throw` after reading this.</span></span>

<span data-ttu-id="cb66a-285">现在，我已经花了一些时间详述了异常处理，接下来将转换话题，探讨使用 `Write-Error -Stop` 在代码中生成错误。</span><span class="sxs-lookup"><span data-stu-id="cb66a-285">Now that I have taken the time to write about exception handling in this detail, I'm going to switch over to using `Write-Error -Stop` to generate errors in my code.</span></span> <span data-ttu-id="cb66a-286">我还将采纳 Kirk 的建议，将 `ThrowTerminatingError` 设为针对每个函数的必备异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="cb66a-286">I'm also going to take Kirk's advice and make `ThrowTerminatingError` my goto exception handler for every function.</span></span>

<!-- link references -->
[powershellexplained.com]: https://powershellexplained.com/
[原始版本]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[original version]: https://powershellexplained.com/2017-04-10-Powershell-exceptions-everything-you-ever-wanted-to-know/
[@KevinMarquette]: https://twitter.com/KevinMarquette
[Reddit/r/PowerShell 社区]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[Reddit/r/PowerShell community]: https://www.reddit.com/r/PowerShell/comments/64866o/kevmar_all_net_46_exceptions_list_for_use_with/
[.NET 异常大列表]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[The big list of .NET exceptions]: https://powershellexplained.com/2017-04-07-all-dotnet-exception-list
[FileNotFoundException]: /dotnet/api/System.IO.FileNotFoundException
[.NET 文档]: /dotnet/api
[.NET documentation]: /dotnet/api
